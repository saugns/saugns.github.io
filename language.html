<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
	<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
	<meta name='description'
content="Overview of the SAU (Scriptable AUdio) language." />
	<meta name='keywords'
content="saugns, SAU language, script syntax" />
	<link rel='stylesheet' href='style.css' type='text/css' title='Default' /><style type='text/css'>@import url("style.css");</style>
<title>SAU overview</title>
</head>
<body>
<div class='nav'><img src="images/sau-logo88x50.png" alt=" " style="float: right" />
Back to <a href='index.html'>main page</a>.
</div>
<h1>SAU language overview</h1>
<p>An overview of how to use the SAU language provided by
the <a href='index.html#saugns'>saugns</a> program.
For how to use saugns command-line options to do various things with scripts,
instead see the <a href='usage.html'>usage</a> page.
</p>
<p>The below is meant to explain the big picture more than cover all details.
A concise language reference listing details more completely can
be found in the <a href='https://github.com/saugns/saugns/blob/stable/doc/README.SAU'>doc/README.SAU</a> file (GitHub view). Syntax changes and feature additions to the language are <a href='changes.html#syntax'>listed here</a>.
</p>
<div class='toc'>
<h2 id='contents'>Contents</h2>
<ul>
<li><a href='#output'>Generating audio</a><ul>
	<li><a href='#modulation'>Using modulation</a><ul>
		<li><a href='#fpm'>Frequency-amplified PM</a></li>
		<li><a href='#modvalrange'>Modulation with value range</a></li>
		</ul>
	</li>
	<li><a href='#timing'>Timing</a><ul>
		<li><a href='#compstep'>Compound steps for an object</a></li>
		<li><a href='#gapshift'>Gapshifts &amp; silent time padding</a></li>
		<li><a href='#timenest'>Combined with nesting</a></li>
		</ul>
	</li>
	<li><a href='#channels'>Channel mixing and panning</a></li>
	</ul>
</li>
<li><a href='#values'>Values and expressions</a><ul>
	<li><a href='#numexp'>Numerical expressions</a><ul>
		<li><a href='#mathfunc'>Mathematical functions</a></li>
		</ul>
	</li>
	<li><a href='#comment'>Comment syntax</a></li>
	<li><a href='#labelref'>Labels and referencing</a></li>
	<li><a href='#ramp'>Value ramps or sweeps</a></li>
	</ul>
</li>
</ul>
</div>
<h2 id='output'>Generating audio</h2>
<p>To generate a single pure tone in the SAU language:
</p>
<pre>Osin f440 p0 a1.0 t1</pre>
<p>In this case, frequency is set to 440 Hz, phase to 0% of the wave cycle,
and amplitude to 1.0 (0dB, no gain change). The time duration will be 1 second. Default values can also be used, by leaving out one or more of the parts after <code>Osin</code>; the above values match those in a script consisting only of <code>Osin</code>, but more generally default values are context-sensitive (especially handling of time lengths).
</p>
<table style="float:right; max-width:50%">
<tr>
	<th>Wave</th><th>Description</th>
</tr>
<tr>
	<td><code>sin</code></td>
	<td>Sine. For cosine, use (1/4) phase.</td>
</tr>
<tr>
	<td><code>sqr</code></td>
	<td>Square.</td>
</tr>
<tr>
	<td><code>tri</code></td>
	<td>Triangle.</td>
</tr>
<tr>
	<td><code>saw</code></td>
	<td>Saw. Increasing slope; use negative amplitude or
	frequency for decreasing slope.</td>
</tr>
<tr>
	<td><code>ahs</code></td>
	<td>Absolute half-frequency sine (adjusted).
	Sine-based parabola-like wave.
	Frequency halved to restore base frequency,
	peak amplitude centered and doubled, phase
	shifted to begin and end at zero amplitude.
	A softer alternative to <code>saw</code> (saw wave).</td>
</tr>
<tr>
	<td><code>hrs</code></td>
	<td>Half-rectified sine (adjusted).
	Positive half kept, negative half zero'd.
	Peak amplitude centered and doubled, phase
	shifted to begin and end at zero amplitude.
	A warm and full sound.</td>
</tr>
<tr>
	<td><code>srs</code></td>
	<td>Square root of sine.
	Mirrored for the negative half.
	A softer alternative to <code>sqr</code> (square wave).</td>
</tr>
<tr>
	<td><code>ssr</code></td>
	<td>Squared &amp; square root of sine.
	A little more thin and sharp, it differs from
	<code>srs</code> a little like <code>srs</code> differs from <code>szh</code>.</td>
</tr>
</table>
<p>The <code>O</code> is the name of the oscillator type,
written to add an oscillator (also called an "operator" in FM synth
terminology) &ndash; immediately followed by a wave type name,
in this case <code>sin</code> (there's more, listed in the table).
</p>
<p>Numbers used above are simple examples of <a href='#numexp'>numerical expressions</a>. Positive numbers are the simplest to write. Fancier things are also possible, including randomized values.
</p>
<p>When top-level or carrier oscillators playing at the same time
increase in number, the amplitude is scaled down for all of them in
proportion (in addition to their individual amplitude settings),
unless this is disabled. This doesn't affect nested or modulator
oscillators, described below.
</p>
<h3 id='modulation'>Using modulation</h3>
<p>Oscillators can be used in a nested way,
as in this example which uses PM (phase modulation):
</p>
<pre>
// Generate 10 seconds of "engine rumble"
Osin f137 t10 p[
	Osin f32 p[
		Osin f42
	]
]
</pre>
<p>The oscillators with frequency 32 Hz and 42 Hz are modulators,
linked in a chain which ends at the carrier (with frequency 137 Hz),
and play for the same time (10 seconds).
(The <code>p</code> is for phase,
and PM means adding modulator amplitudes to the phase.)
Above, the amplitudes are all left at the default 1.0;
those of modulators determine what is often called the
modulation index or "depth" of modulation.
</p>
<p>Modulators only ever run when their carriers do, and
by default, if no time duration is set for a modulator,
it will also be otherwise unlimited. But each modulator
can also have a time duration in seconds of its own set
in the same way as for a carrier, and then will run for
the shortest of the times. (If the carrier time expires
first, this will "pause" the modulator unless and until
the time is extended, if that's done.) The special time
which is default for modulators can also be set, as the
non-number value <code>i</code> (implicit time), though
only for modulators.
</p>
<p>For modulators, frequency can be specified using the
<code>r</code> (relative frequency) parameter instead of
the usual <code>f</code> (frequency) parameter; whichever
is most recently set will be used to get the frequency.
A value assigned to <code>r</code> will be multiplied by
the carrier frequency in order to give the frequency of
the modulator. For example, a modulator with <code>r4/3</code>
will maintain a frequency 4/3 times the frequency of the carrier;
changing the <code>f42</code> in the example above to that gives
a somewhat different sound.
</p>
<p><a href='#ramp'>Ramping or sweeping</a> parameters like amplitude or frequency is a little like using modulation features, except that the source of the change is not an oscillator, but simply a one-off timed trajectory. Modulation can become more interesting when that's done to parameters altering the result.
</p>
<p>Frequency and amplitude can be given values which are computed
using oscillator outputs shifted to a range. This includes "real FM",
as well as the modulations of amplitude called amplitude and ring
modulation. See the section
<a href='#modvalrange'>Modulation with value range</a> for more.
</p>
<p>Finally, the result of both PM and other types of modulation can be altered
&ndash; sometimes not audibly, sometimes very audibly &ndash; by changing phase
for a carrier or a modulator (with a number after a <code>p</code>), changing
how the waveforms produced by the two line up relative to one another, and so
how one of them ends up affecting the other.
</p>
<h4 id='fpm'>Frequency-amplified PM</h4>
<p>There's two different ways to connect a PM (phase modulation) input
to a carrier, normal PM (<code>p[...]</code>) as described above, and
the similarly-used frequency-amplified PM (<code>pf[...]</code>) which
multiplies modulator amplitudes by the carrier frequency (scaled down
so that 632.45... Hz, the geometric mean of the 20&ndash;20000 Hz human
hearing range, makes level "normal"). The best PM type to use depends
on the intended sound as the carrier pitch varies. Both modulator types
can be linked to a carrier, so the choice can be made per modulator.
</p>
<p>Changing the frequency of a carrier changes how fast its phase moves
independently of any PM. When the PM signal also remains the same while
frequency is changed, this changes the proportion of the two sources of
phase movement for the carrier. For example, this affects how a vibrato
effect from PM will sound as the carrier plays at different pitches; at
higher pitch, e.g. twice the frequency, the PM has only half the impact
<i>relative</i> to it. Frequency-amplified PM makes a constant "impact"
by multiplying the carrier frequency into the PM signal.
</p>
<p>However, when modulator frequency is set relative (<code>r</code>) to a
carrier as a multiplier for its frequency, it's normal PM that sounds more
equal in intensity as the carrier pitch varies. With the combining of both
types of linkage to the carrier frequency, higher-pitched sounds stand out
more sharply, as the modulation input energy increases two ways instead of
only one way.
</p>
<p>When comparing normal and frequency-amplified PM, keep in mind that changes
in modulator amplitude can counter-intuitively affect the color of the sound,
just like changes in the phase offsets for carrier relative to modulator can.
To ease comparing and "tuning" sounds, the named constant <code>mf</code> can
be used for the 632.45... Hz number when setting parameter values. For example,
if a carrier has a frequency of 100 Hz, then setting the f-PM modulator
amplitude with <code>a(mf/100)</code> brings the same result as
for a normal PM modulator with <code>a1.0</code>.
</p>
<h4 id='modvalrange'>Modulation with value range</h4>
<p>Amplitude (<code>a</code>) and frequency (<code>f</code>)
(and relative frequency <code>r</code>) parameters support
modulation of the parameter values within a bounded value range.
(For amplitude, whether this modulation is called amplitude
modulation (AM) or ring modulation (RM) is a matter of the value
range. Ring modulation has the same magnitude for the upper and
lower bound, but with differing sign, while classic amplitude
modulation has one of the bounds set to zero. The term AM has been used
more generally for the full range of variation in the software, but for
clarity it's best to note that classic AM and RM are both special cases.)
</p>
<p>The two bounds of the value range come from the two (!) values of the
parameter: the normal value generally used, and a second value which is
only used for this type of modulation and which defaults to 0.0.
(The second value can also be <a href='#ramp'>ramped or swept</a>
like the first, with the same syntax used in place of a number.)
Separating the two values is <code>w,</code> (where the letter "w" is
short for "wave envelope"). If the second value is left out,
the <code>,</code> is ignored and can also be left out.
</p>
<p>A simple FM example (where frequency is varied between 250 Hz and 500 Hz, using a 0.1 Hz sine wave):
</p>
<pre>
Osin f250w,500[Osin f0.1] t10
</pre>
<p>A simple AM example (where amplitude is varied between 1/4 and full, using a half-rectified sine wave with 1/5 of the carrier's frequency):
</p>
<pre>
Osin f200 a1/4w,4/4[Ohrs r(1/5)] t5
</pre>
<p>The second value can also be set without changing the first value
for the parameter, by writing nothing before the <code>w</code>.
It's also possible to leave out the second value, or both.
</p>
<p>After <code>w</code>, or <code>w,</code> and optionally a value, <code>[]</code> (tilde and
square brackets) can be used to set a list of modulator operators specified
within the <code>[]</code>; the list replaces any previous set,
and may be empty.
</p>
<p>Each modulator in the list will produce a result in the range
of 0.0 to 1.0, i.e. a positive signal, multiplied by its amplitude
parameter (defaulting to 1.0), negative amplitude multipliers having
the effect of switching the top and bottom of the 0.0 to 1.0 range.
Setting (changing) the amplitude for modulators will thus change
the range when the absolute value is not 1.0, but this is allowed
for the sake of flexibility.
</p>
<p>The product of modulator amplitudes is mapped to the value
range; 0.0 means the normal value and 1.0 means the second value.
This adds a bias towards the normal value with more modulators used.
</p>
<h3 id='timing'>Timing</h3>
<p>Things in a script all have the same time placement, i.e. they begin or take effect at the same time, unless the time position is changed. Playing several things at the same time is easy &ndash; just write one thing after the next &ndash; while there's several ways to arrange them differently than that.
</p>
<p>A <code>/number</code>, with "number" a time in seconds, adds
a delay to everything after; it's the global forward-shift option, added
between two parts of a script. The time separator <code>|</code>
is related and adjusts the delay added to everything after so it
exactly matches the duration, or play time, remaining for things
before it. (When both of these options are used together,
the order of use is important.)
</p>
<p>To generate two tones, separated in time,
and also insert an extra 2.5 seconds of silence in-between them:
</p>
<pre>
Osin f440 t2
| /2.5
Osin f220 t2
</pre>
<p>While those two timing modifiers apply to everything which follows
after in a script, there's other options which only apply more locally,
described below.
</p>
<h4 id='compstep'>Compound steps for an object</h4>
<p>The numberless <code>;</code> sub-step separator splits and extends the duration of a step for some object into two parts, one placed directly after the other. Parameter changes written after it will take place just after the time duration of the preceding part, and the following part will in turn have a new time duration. It can be used any number of times in a row, timing only changing locally within the compound step built this way.
</p>
<p>It's often the simplest way of arranging a series of timed changes for an object. The following example plays four tones in sequence, each for 1.5 seconds:
</p>
<pre>
Osin t1.5 f100; f200; f300; f400
</pre>
<p>Here all four time durations are 1.5 seconds, for 6 seconds in total, because the default time for the 2nd part is copied from the 1st, and that of the 3rd is copied from the 2nd, etc. That's the rule, though there is one exception for it for <a href='#modulation'>modulators</a>; just like modulators generally have the special time value <code>i</code> (implicit time) by default, for modulators the <i>last</i> sub-step has that as the default time, so that using <code>;</code> does not unexpectedly shorten the time.
</p>
<p>Silent gaps can also be inserted within a compound step, adding to the duration, using the <code>;number</code> gapshift syntax described more generally in the next section. A <code>;number</code> written just after a <code>;</code> adds a local time delay "number" of seconds long inside the compound step, analogous to using the more global <code>|</code> and <code>/number</code>-syntaxes together. For example, to add a 0.5 second silent gap between each change of tone in the current example:
</p>
<pre>
Osin t1.5 f100;;0.5 f200;;0.5 f300;;0.5 f400
</pre>
<h4 id='gapshift'>Gapshifts &amp; silent time padding</h4>
<p>The gapshift <code>;number</code>-syntax looks somewhat like
the more global <code>/number</code>-syntax, similarly allowing
time in seconds to be entered as a delay time &ndash; but only
for the current step for some object. It behaves much like the
<a href='#compstep'>compound step</a> numberless <code>;</code>
and is another way to split a step and forward-shift the later
part in time. The main use is to move a (sub-)step forward and
leave a silent gap at the old position, but it can also extend
the duration without leaving a silent gap.
</p>
<p>Using <code>;number</code> always resets time for the new part
each use if a new <code>t</code> value is not provided. Unlike on
use of<code>/number</code>, a long shift doesn't simply move past
a short time expired; if it moves past sound to silence, then the
silence may also be followed by sound with a new play time added.
</p>
<p>It's possible to use only <code>;number</code> in place of the
numberless <code>;</code>, but it may be more messy. For example,
with two oscillators inserted at the same time, for the first of
them. Time should be explicitly set before the <code>;1</code> is
used, thereafter play time for the first oscillator will extend,
rather than move; it will play for 3 seconds rather than 2, with
the time reset to the previous value, 2 seconds, after 1 second.
</p>
<pre>
Osin f440 t2 ;1 f220
Osin f110
</pre>
<p>Note that the setting of a time value explicitly for the first
oscillator above, <i>before</i> the <code>;1</code>, is important;
otherwise the peculiar behavior is to insert a pause or "rest" by
making default time 0 before the <code>;number</code> while after
it, the old default time is copied if a new time isn't set there.
Changing the order to <code>;1 t2</code>, the first 1 second will
be blank for the first oscillator, and it will only play the last
2 seconds with 220 Hz (never with 440 Hz). Another example, where
a tone plays after 1 second (for the usual default time) follows:
</p>
<pre>
Osin ;1 f880
</pre>
<p>Here nothing is missing and the delay is intended. Such use of
silent time padding may mainly be interesting inside nested lists
(to make another modulator start to play after a delay, say) when
used by itself.
</p>
<p>There's also another way to control the behavior of moving vs.
extending, to disable or adjust the proportion of silent padding.
When several <code>;number</code> are used in series &ndash; with
no numberless <code>;</code> or other timing modifier in-between
&ndash; then only the first can zero the time before it. So, for
example, <code>;0 ;1</code> will never move more than 0 seconds,
then will extend by 1 second.
</p>
<h4 id='timenest'>Combined with nesting</h4>
<p>The flow of time and the nesting of scopes are like two dimensions in which things are arranged &ndash; which corresponds to how the text in a script looks. When objects are placed inside of lists for nesting, as when adding <a href='#modulation'>modulators</a>, the same time placement is used for the contents of the list as for where the list is assigned. In turn, inside of a list, a step written for an object can have sub-steps (using <code>;</code> and/or <code>;number</code> as described above), making for timing offsets which then apply for further lists assigned there in particular within the list.
</p>
<p>Currently, the global timing <code>/number</code> and <code>|</code> syntax is not allowed inside of modulator lists, only at the top scope (where they are also the most useful). A way to use them at the level of a subscope block may be added in the future, as an alternative to using only the compound step syntax (which only applies to the current individual object and that which is nested below).
</p>
<p>Here's an example of both timing and nesting which builds up a richer and richer noise, using PM, second by second.
</p>
<pre>
Osin f400 t1; p[
	Osin ;0 r(3/4) ;1 p[Osin f500 a1/5; a1/4; a1/3; a1/2; a1/1]
	Osin ;2 r(3/5)
	Osin ;4 r(3/6) ;1 p[Osin f300 a1/5; a1/4; a1/3; a1/2; a1/1]
	Osin ;6 r(3/7)
	Osin ;8 r(3/8) ;1 p[Osin f100 a1/5; a1/4; a1/3; a1/2; a1/1]
] t10; f800 t4
</pre>
<p>A timed series of changes for an object can, of course, also include smoothly <a href='#ramp'>ramped values</a>. Here is a modification of the PM "engine rumble" example which produces something differently-sounding, morphing over time as the innermost oscillator has its frequency ratio swept towards a series of new values &ndash; along with a little silent gap in the middle.
</p>
<pre>
Osin f137 t11 p[
	Osin f32 p[
		Osin r50*1.0 r{g50*0.1}; r{g50*0.2}; r{g50*0.25} t2.0
		; t1.5; t0.0; ;1.0 r{g50*0.75 t1} t2; r{g50*0.0} t0.5
		; r{g50*2.0} t2.0
	]
]
</pre>
<h3 id='channels'>Channel mixing and panning</h3>
<p>SAU supports stereo audio, but oscillators pass mono signals between one another. Objects which are not used as modulators, whose output is mixed into the result, have an extra channel mixing parameter <code>c</code> which defaults to centered mixing, or <code>0.0</code>. It can be changed in order to pan sounds. For convenience, the constants <code>L</code> for hard left, <code>C</code> for center, and <code>R</code> for hard right, can be used as values; this works the same as entering the corresponding numbers <code>(-1.0)</code>, <code>0.0</code>, and <code>1.0</code>.
</p>
<p>For example, to play a tone starting at the left and moving linearly to the right over 3 seconds using a <a href='#ramp'>value ramp</a>:
</p>
<pre>
Osin f440 cL c{gR t3} t3
</pre>
<p>The inner <code>t3</code> above is actually optional, since the outer sets its default to that.
</p>
<p>It's possible to pan harder than hard left and hard right; going "too far" in either direction simply amplifies what's added to that channel while giving what's added to the other a negative amplitude.
</p>
<h2 id='values'>Values and expressions</h2>
<p>For most parameters, a single number is a value; see
<a href='#numexp'>numerical expressions</a> below for how to write them.
More complex types of values which include numbers also exist.
Some parameters support timed <a href='#ramp'>value ramping or sweeping</a>.
</p>
<p>For all types of modulation, the <i>list</i> of oscillators is used
as a type of parameter value, supported in a nested way. Frequency and
amplitude parameters combine that with numbers, for FM or AM/RM
<a href='#modvalrange'>with a value range</a>, respectively.
</p>
<p><a href='#comment'>Comments</a> are text which is ignored;
several comment styles are supported.
</p>
<h3 id='numexp'>Numerical expressions</h3>
<p>Each number can be written with or without a decimal point.
If a decimal point is used, a leading <code>0</code> can be left out,
as in <code>.25</code>.
</p>
<table style="float:right; max-width:50%">
<tr>
	<th>Symbol</th><th>Description</th>
</tr>
<tr>
	<td><code>^</code></td>
	<td>To the power of (right-associative)</td>
</tr>
<tr>
	<td><code>*</code> <code>/</code> <code>%</code></td>
	<td>Multiplication, division, remainder</td>
</tr>
<tr>
	<td><code>+</code> <code>-</code></td>
	<td>Addition, subtraction</td>
</tr>
</table>
<p>Number signs and arithmetic operation symbols can be used in infix
expressions, together with numbers and named constants and functions.
The rules are fairly simple and conventional, including precedence as in the
table shown. Nested parentheses can be used freely. Parentheses also allow
multiplication in the customary way,
e.g. <code>2(3)</code> means <code>6</code>.
But unless a numerical expression is written within parentheses,
it cannot contain any whitespace, as it ends the expression.
For example, <code>-1</code> is fine, but <code>- 1</code>
is a dangling minus followed by a dangling number 1,
if not inside parentheses as <code>(- 1)</code>.
</p>
<p>The ability to write almost any expression, sans whitespace, without any surrounding parentheses is for convenience. For example, writing rational numbers with a division, e.g. <code>1/2</code>, is often useful in scripts and this keeps it short. However, in some cases parentheses are required to keep apart mathematical names and surrounding alphanumeric characters which may optionally be added <i>after</i> a main parameter name as part of a larger expression.
</p>
<p>Some parameters support named constants specific to that type
of value; unlike other names, they are capital one-letter names.
</p>
<h4 id='mathfunc'>Mathematical functions</h4>
<p>A set of mathematical functions are supported in expressions for
all parameters, whether or not surrounding parentheses are used.
Writing <code>name(value)</code> gives the result of applying the
function <code>name</code> to the value. A few functions give a
value without being provided any, like <code>rand()</code>, which
returns a new pseudo-random value from 0.0 to 1.0 each time it is called.
</p>
<table style="float:right; max-width:50%">
<tr>
	<th>Name</th><th>Description</th>
</tr>
<tr>
	<td><code>abs(x)</code></td>
	<td>Absolute value.</td>
</tr>
<tr>
	<td><code>cos(x)</code></td>
	<td>Cosine of value.</td>
</tr>
<tr>
	<td><code>exp(x)</code></td>
	<td>Base-e exponential value.</td>
</tr>
<tr>
	<td><code>log(x)</code></td>
	<td>Natural logarithmic value.</td>
</tr>
<tr>
	<td><code>met(x)</code></td>
	<td>Metallic value, e.g. <code>met(1)</code> gives the golden ratio.
	Positive integers give the series of metallic ratios.
	Other values are also allowed: fractional, 0 giving 1
	and negative (gives how much the positive value would
	be increased, approaching zero further from zero).
	Note that <code>met(-x)</code> is also equal to <code>(1/met(x))</code>.</td>
</tr>
<tr>
	<td><code>mf</code></td>
	<td>632.45... (Geometric mean of 20 and 20000.)</td>
</tr>
<tr>
	<td><code>pi</code></td>
	<td>3.1415...</td>
</tr>
<tr>
	<td><code>rand()</code></td>
	<td>Pseudo-random number in range 0-1. The value sequence
	from a series of calls restarts each new script unit.</td>
</tr>
<tr>
	<td><code>rint(x)</code></td>
	<td>Round value to the nearest integer. Halfway cases are
	rounded to the nearest even integer.</td>
</tr>
<tr>
	<td><code>seed(x)</code></td>
	<td>Reset the <code>rand()</code> value sequence with a passed number.
	(Every bit counts; different expressions for the same
	number, with e.g. rounding may give different seeds.)
	Returns 0 so that e.g. <code>/seed(100)</code> will only reseed.</td>
</tr>
<tr>
	<td><code>sin(x)</code></td>
	<td>Sine of value.</td>
</tr>
<tr>
	<td><code>sqrt(x)</code></td>
	<td>Square root.</td>
</tr>
<tr>
	<td><code>time()</code></td>
	<td>Get a system timestamp number changed each second.
	It can be used for seeding in a randomized script.
	(Note that the exact value is platform-dependent.)</td>
</tr>
</table>
<p>A musically interesting function for frequency ratios and some other uses may be <code>met(x)</code>, which produces the <a href="https://en.wikipedia.org/wiki/Metallic_mean">metallic means/ratios/constants</a> (the Wikipedia article has the formula used); for example, the <a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a> value of 1.618... is the result of <code>met(1)</code>, and a modulator oscillator can have its <code>r</code> parameter set to that with <code>rmet(1)</code>. This function makes it easy to produce more complex frequency spectrums with FM or PM by providing more irrational numbers in response to simpler ones typed. (The function can take any value, also producing "metallic values" between the "proper" ones for the integers. Negative values also give how much the positive would be increased, which is less further from zero.)
</p>
<p>Most functions return values meant to be assigned to something &ndash; like a parameter for an object, or a value for a <a href='#timing'>delay time modifier</a> &ndash; or to be passed on to other functions. Unlike other functions, the <code>seed(x)</code> function does not return a value meant to do anything, just 0. How to use it? Instead of making a frivolous parameter assignment simply in order to use it so that it produces its side effect (re-seeding random number generation), a tidy convention is to call it following a delay-slash, <code>/seed(...)</code>. Given the number 0, the delay-slash will do nothing. This can be placed anywhere in the top scope of a script, including at the beginning of the script.
</p>
<h3 id='comment'>Comment syntax</h3>
<p>Several comment styles exist:
</p>
<ul>
<li><code>//</code> (C++-style comment) comments out the rest of a line.</li>
<li><code>/*</code> (C-style comment) comments out text until the next <code>*/</code>. Does not nest.</li>
<li><code>#!</code> (Shebang) comments out the rest of a line.</li>
<li><code>#Q</code> (Quit file) comments out the rest of the whole file.</li>
</ul>
<h3 id='labelref'>Labels and referencing</h3>
<p>The declaration of an object can be prefixed by <code>'name </code>
to label the object "name". Each name written is a case-sensitive
string with alphanumeric characters and/or underscores.
Once labeled, the object can be referred back to by writing <code>@name</code>
at any later point in the script. Adding such a <code>@name</code> reference
for an object does not automatically set a new time duration for that object.
(A new time value is set if any changes made to parameters include
explicitly setting <code>t</code> (time), or if a step-splitting
<a href='#timing'>timing</a> modifier is used.)
</p>
<p>Note that a <code>@name</code> reference placed in a nesting scope
different from the original (i.e. outside a list, or in a new list, etc.)
does not move the object into the new nesting scope. It will not be added
to, nor removed from, any list by being referenced anywhere.
The time scope is however new and of the reference.
</p>
<p>For example, the <a href='#modulation'>modulator</a> used in this PM example is labeled "name", and is then accessed using its label in order to change its frequency relative to the carrier at one-second intervals:
</p>
<pre>
Osin f500 t5 p[
	'name Osin r1/1
]

/1
@name r1/2
/1
@name r1/3
/1
@name r1/4
/1
@name r1/5
</pre>
<p>Here the timing would also change for anything written
afterwards (in a longer script) with every <code>/1</code>.
The <a href='#timing'>timing</a> section describes more means of
placing changes in time. The numberless <code>;</code>-separator
is often a neater alternative to label referencing,
but can also be combined with it. (Here it uses the
<code>t</code> value of each preceding part to only
locally delay the sub-step which follows it.)
</p>
<pre>
/1
@name r1/2 t1
; r1/3 t1
; r1/4 t1
; r1/5
</pre>
<p>In some cases, it's shorter and simpler to use the numbered form
of the <code>;</code>-separator, called a <a href='#gapshift'>gapshift</a>.
Like the first example, this skips the use of <code>t</code> to set how long
to wait between parts. Each <code>/1</code> is replaced by a <code>;1</code>
for a continuing <code>@name</code> reference. A gapshift combines with such
references without making the first part silent, because the initial use of
<code>@name</code> never <i>automatically</i> sets a new time duration,
unlike later sub-steps, and unlike freshly added objects.
</p>
<pre>
/1
@name r1/2 ;1 r1/3 ;1 r1/4 ;1 r1/5
</pre>
<h3 id='ramp'>Value ramps or sweeps</h3>
<p>To ramp, or sweep, a parameter towards a goal value,
a set of value ramp arguments can be given within <code>{}</code>
in place of the usual one numerical argument.
This is currently supported for amplitude, frequency, and
<a href='#channels'>channel mixing</a> parameters.
The usual number is used as the starting value for the trajectory,
and the parameter can be assigned a value twice in order to provide both.
</p>
<p>For example, the following tone begins at 20 Hz
and rises exponentially to 20000 Hz, over 10 seconds:
</p>
<pre>Osin f20 f{g20000 rexp} t10 a0.25</pre>
<p>Here, <code>r</code> is a subparameter which changes the ramp shape (the default being a linear ramp). Note that the ramp shapes are not the same as any mathematical functions with the same names. Each fills in points between the beginning (usual number) and the end value (<code>g</code>) in some way.
</p>
<table style="float:right; max-width:50%">
<tr>
	<th>Shape</th><th>Description</th>
</tr>
<tr>
	<td><code>hold</code></td>
	<td>Hold old value until time.</td>
</tr>
<tr>
	<td><code>lin</code></td>
	<td>Linear trajectory over time.</td>
</tr>
<tr>
	<td><code>sin</code></td>
	<td>Sine-like smooth ends trajectory over time.</td>
</tr>
<tr>
	<td><code>exp</code></td>
	<td>Steep <code>exp(x)-1</code>-like increase or decrease.</td>
</tr>
<tr>
	<td><code>log</code></td>
	<td>Steep <code>log(x+1)</code>-like increase or decrease.</td>
</tr>
<tr>
	<td><code>xpe</code></td>
	<td>Exponential envelope shape (saturate or decay).</td>
</tr>
<tr>
	<td><code>lge</code></td>
	<td>Logarithmic envelope shape (saturate or decay).</td>
</tr>
</table>
<p>The ramp sub-parameters are as follows. The default values often allow one or two of them to be left out.
</p>
<dl>
	<dt><code>g</code></dt>
	<dd>Goal (go-to) value, assigned to the parameter after time.
	This value has no default and must be provided.</dd>
	<dt><code>r</code></dt>
	<dd>Ramp fill shape (default <code>lin</code>).
	The <code>exp</code> and <code>log</code> shapes use ear-tuned polynomial
	approximations with definite beginnings and ends,
	designed to sound natural for frequency sweeping,
	and symmetric one to the other. The <code>xpe</code> shape increases
	like <code>log</code> and decreases like <code>exp</code>, much like a capacitor
	charges and discharges, natural-sounding for an envelope;
	and <code>lge</code> increases like <code>exp</code> and decreases like <code>log</code>.
	The <code>sin</code> shape sounds similar to <code>lin</code>, except it has a
	smoothly curved start and stop, and a steeper middle.</dd>
	<dt><code>t</code></dt>
	<dd>Time to reach goal (default is the external <code>t</code> duration).</dd>
</dl>
<div class='footer'>Text available under version 4.0 of <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons BY-SA" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>.
</div>
</body>
</html>
